#Сортировка выбором 

def selection_sort(arr):
    """
    Сортировка выбором - на каждом проходе находим минимальный элемент
    и помещаем его на текущую позицию
    """
    # Проходим по всем элементам массива
    for i in range(len(arr)):
        # Предполагаем, что минимальный элемент находится на текущей позиции
        min_index = i
        
        # Ищем минимальный элемент в оставшейся части массива
        for j in range(i + 1, len(arr)):
            # Если находим элемент меньше текущего минимального
            if arr[j] < arr[min_index]:
                # Обновляем индекс минимального элемента
                min_index = j
        
        # Если минимальный элемент не на своем месте, меняем их местами
        if min_index != i:
            # Меняем элементы местами с использованием кортежного присваивания
            arr[i], arr[min_index] = arr[min_index], arr[i]
    
    return arr

#сортировка обменом 

def bubble_sort(arr):
    """
    Пузырьковая сортировка - последовательно сравниваем соседние элементы
    и меняем их местами, если они находятся в неправильном порядке
    """
    n = len(arr)  # Получаем длину массива
    
    # Внешний цикл - количество проходов по массиву
    for i in range(n - 1):
        # Внутренний цикл - сравнение соседних элементов
        for j in range(0, n - i - 1):
            # Если текущий элемент больше следующего
            if arr[j] > arr[j + 1]:
                # Меняем элементы местами
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    
    return arr

#сортировка вставками 

def insertion_sort(arr):
    """
    Сортировка вставками - каждый следующий элемент вставляется
    в правильную позицию в отсортированной части массива
    """
    # Начинаем со второго элемента (индекс 1)
    for i in range(1, len(arr)):
        key = arr[i]  # Запоминаем текущий элемент для вставки
        j = i - 1     # Начинаем сравнение с предыдущего элемента
        
        # Сдвигаем элементы большие key вправо
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]  # Сдвигаем элемент вправо
            j -= 1               # Переходим к следующему элементу слева
        
        # Вставляем key на правильную позицию
        arr[j + 1] = key
    
    return arr

#сортировка слиянием 

def merge_sort(arr):
    """
    Сортировка слиянием - разделяй и властвуй:
    массив делится пополам, каждая половина сортируется рекурсивно,
    затем отсортированные половины сливаются
    """
    # Базовый случай: массивы длиной 0 или 1 уже отсортированы
    if len(arr) <= 1:
        return arr
    
    # Находим среднюю точку для разделения массива
    mid = len(arr) // 2
    
    # Рекурсивно сортируем левую и правую половины
    left_half = merge_sort(arr[:mid])
    right_half = merge_sort(arr[mid:])
    
    # Объединяем отсортированные половины
    return merge(left_half, right_half)

def merge(left, right):
    """
    Функция для слияния двух отсортированных массивов
    """
    result = []  # Результирующий массив
    i = j = 0    # Индексы для левого и правого массивов
    
    # Сливаем массивы, пока в обоих есть элементы
    while i < len(left) and j < len(right):
        # Выбираем меньший элемент из двух массивов
        if left[i] <= right[j]:
            result.append(left[i])  # Добавляем элемент из левого массива
            i += 1                  # Переходим к следующему элементу левого массива
        else:
            result.append(right[j]) # Добавляем элемент из правого массива
            j += 1                  # Переходим к следующему элементу правого массива
    
    # Добавляем оставшиеся элементы из левого массива (если есть)
    while i < len(left):
        result.append(left[i])
        i += 1
    
    # Добавляем оставшиеся элементы из правого массива (если есть)
    while j < len(right):
        result.append(right[j])
        j += 1
    
    return result

#сортировка Шелла

def shell_sort(arr):
    """
    Сортировка Шелла - улучшенная версия сортировки вставками,
    которая сортирует элементы на определенных расстояниях (промежутках)
    """
    n = len(arr)  # Получаем длину массива
    
    # Начинаем с большого промежутка, затем уменьшаем его
    gap = n // 2  # Начальный промежуток
    
    while gap > 0:
        # Выполняем сортировку вставками для этого промежутка
        for i in range(gap, n):
            temp = arr[i]  # Сохраняем текущий элемент
            j = i          # Начинаем с текущей позиции
            
            # Сдвигаем элементы, пока не найдем правильную позицию
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]  # Сдвигаем элемент
                j -= gap               # Переходим к предыдущему элементу с шагом gap
            
            # Вставляем сохраненный элемент в правильную позицию
            arr[j] = temp
        
        # Уменьшаем промежуток
        gap //= 2
    
    return arr

#быстрая сортировка 

def quick_sort(arr):
    """
    Быстрая сортировка - алгоритм "разделяй и властвуй":
    выбираем опорный элемент и разделяем массив на элементы меньше опорного
    и элементы больше опорного, затем рекурсивно сортируем обе части
    """
    # Базовый случай: массивы длиной 0 или 1 уже отсортированы
    if len(arr) <= 1:
        return arr
    
    pivot = arr[len(arr) // 2]  # Выбираем опорный элемент (середина массива)
    
    # Разделяем массив на три части:
    left = [x for x in arr if x < pivot]      # Элементы меньше опорного
    middle = [x for x in arr if x == pivot]   # Элементы равные опорному
    right = [x for x in arr if x > pivot]     # Элементы больше опорного
    
    # Рекурсивно сортируем левую и правую части, объединяем с серединой
    return quick_sort(left) + middle + quick_sort(right)

#пирамидальная сортировка 

def heap_sort(arr):
    """
    Пирамидальная сортировка - преобразуем массив в двоичную кучу (heap),
    затем последовательно извлекаем максимальные элементы
    """
    n = len(arr)  # Получаем длину массива
    
    # Построение max-heap (перегруппировка массива)
    # Начинаем с последнего нелистового узла
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    
    # Извлекаем элементы из кучи один за другим
    for i in range(n - 1, 0, -1):
        # Перемещаем текущий корень (максимальный элемент) в конец
        arr[i], arr[0] = arr[0], arr[i]
        
        # Вызываем heapify на уменьшенной куче
        heapify(arr, i, 0)
    
    return arr

def heapify(arr, n, i):
    """
    Преобразование поддерева в max-heap
    """
    largest = i        # Инициализируем наибольший элемент как корень
    left = 2 * i + 1   # Левый дочерний элемент
    right = 2 * i + 2  # Правый дочерний элемент
    
    # Если левый дочерний элемент существует и больше корня
    if left < n and arr[left] > arr[largest]:
        largest = left
    
    # Если правый дочерний элемент существует и больше текущего наибольшего
    if right < n and arr[right] > arr[largest]:
        largest = right
    
    # Если наибольший элемент не корень
    if largest != i:
        # Меняем местами корень и наибольший элемент
        arr[i], arr[largest] = arr[largest], arr[i]
        
        # Рекурсивно преобразуем затронутое поддерево
        heapify(arr, n, largest)

#последовательный поиск 

def linear_search(arr, target):
    """
    Последовательный поиск - проверяем каждый элемент массива по порядку
    """
    # Проходим по всем элементам массива
    for i in range(len(arr)):
        # Если нашли целевой элемент
        if arr[i] == target:
            return i  # Возвращаем индекс найденного элемента
    
    # Если элемент не найден, возвращаем -1
    return -1

#бинарный поиск 

def binary_search(arr, target):
    """
    Бинарный поиск - работает только на отсортированных массивах.
    На каждом шаге уменьшает область поиска вдвое.
    """
    left = 0                    # Левая граница поиска
    right = len(arr) - 1        # Правая граница поиска
    
    # Пока левая граница не превысила правую
    while left <= right:
        mid = (left + right) // 2  # Находим середину
        
        # Если элемент в середине равен целевому
        if arr[mid] == target:
            return mid  # Возвращаем индекс
        
        # Если целевой элемент меньше среднего
        elif arr[mid] > target:
            right = mid - 1  # Ищем в левой половине
        
        # Если целевой элемент больше среднего
        else:
            left = mid + 1   # Ищем в правой половине
    
    # Если элемент не найден
    return -1

#интерполирующий поиск 

def interpolation_search(arr, target):
    """
    Интерполирующий поиск - улучшенный бинарный поиск, который
    использует интерполяцию для определения позиции поиска
    """
    low = 0                    # Нижняя граница
    high = len(arr) - 1        # Верхняя граница
    
    # Пока целевой элемент находится между границами и границы не совпали
    while low <= high and target >= arr[low] and target <= arr[high]:
        # Если границы совпали
        if low == high:
            # Если элемент найден, возвращаем индекс
            if arr[low] == target:
                return low
            return -1  # Иначе возвращаем -1
        
        # Вычисляем позицию с помощью интерполяционной формулы
        # Формула: pos = low + ((target - arr[low]) * (high - low)) // (arr[high] - arr[low])
        pos = low + ((target - arr[low]) * (high - low)) // (arr[high] - arr[low])
        
        # Если элемент найден
        if arr[pos] == target:
            return pos  # Возвращаем позицию
        
        # Если целевой элемент меньше элемента в позиции pos
        if arr[pos] > target:
            high = pos - 1  # Ищем в левой части
        else:
            low = pos + 1   # Ищем в правой части
    
    # Если элемент не найден
    return -1

#поиск Фибоначчи 

def fibonacci_search(arr, target):
    """
    Поиск Фибоначчи - использует числа Фибоначчи для определения
    позиций сравнения, работает на отсортированных массивах
    """
    n = len(arr)  # Длина массива
    
    # Инициализируем числа Фибоначчи
    fib_m2 = 0          # (m-2)-е число Фибоначчи
    fib_m1 = 1          # (m-1)-е число Фибоначчи
    fib_m = fib_m2 + fib_m1  # m-е число Фибоначчи
    
    # Находим наименьшее число Фибоначчи, большее или равное n
    while fib_m < n:
        fib_m2 = fib_m1
        fib_m1 = fib_m
        fib_m = fib_m2 + fib_m1
    
    offset = -1  # Отметка об исключенном диапазоне
    
    # Пока есть элементы для проверки
    while fib_m > 1:
        # Проверяем, valid ли fib_m2
        i = min(offset + fib_m2, n - 1)
        
        # Если target больше значения в i, отсекаем подмассив от offset до i
        if arr[i] < target:
            fib_m = fib_m1
            fib_m1 = fib_m2
            fib_m2 = fib_m - fib_m1
            offset = i
        
        # Если target меньше значения в i, отсекаем подмассив после i
        elif arr[i] > target:
            fib_m = fib_m2
            fib_m1 = fib_m1 - fib_m2
            fib_m2 = fib_m - fib_m1
        
        # Элемент найден
        else:
            return i
    
    # Сравниваем последний элемент
    if fib_m1 == 1 and offset + 1 < n and arr[offset + 1] == target:
        return offset + 1
    
    # Элемент не найден
    return -1

