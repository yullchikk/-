вариант 16- реализуйте три вида обхода бинарного дерева (preorder, inorder, postorder).
1. Preorder (прямой обход: корень → левое → правое)
Суть: сначала обрабатываем текущий узел, затем рекурсивно обходим левое и правое поддеревья.
Порядок посещения узлов:
Корень → Левое поддерево → Правое поддерево
Рекурсивный алгоритм:
1. Если текущий узел null — выйти (базовый случай).
2. Обработать (вывести/сохранить) значение текущего узла.
3. Рекурсивно вызвать preorder для левого ребёнка.
4. Рекурсивно вызвать preorder для правого ребёнка.
Пример последовательности (для дерева на рисунке ниже):
A → B → D → E → C → F → G
   A
  / \
 B   C
/ \ / \
D  E F  G
Шаги:
Порядок шагов:
1. Обработать (вывести/сохранить) значение текущего узла (корня поддерева).
2. Рекурсивно обойти левое поддерево.
3. Рекурсивно обойти правое поддерево.
print(root.val, end=" ")  # шаг 1: обработка корня
preorder(root.left)         # шаг 2: обход левого поддерева
preorder(root.right)        # шаг 3: обход правого поддерева
2. Inorder (центральный обход: левое → корень → правое)
Суть: рекурсивно обходим левое поддерево, затем обрабатываем корень, затем правое поддерево.
Порядок посещения узлов:
Левое поддерево → Корень → Правое поддерево
Рекурсивный алгоритм:
1. Если текущий узел null — выйти.
2. Рекурсивно вызвать inorder для левого ребёнка.
3. Обработать значение текущего узла.
4. Рекурсивно вызвать inorder для правого ребёнка.
Пример последовательности (для того же дерева):
D → B → E → A → F → C → G
Порядок шагов:
1. Рекурсивно обойти левое поддерево.
2. Обработать значение текущего узла (корня поддерева).
3. Рекурсивно обойти правое поддерево.
inorder(root.left)          # шаг 1: обход левого поддерева
print(root.val, end=" ")   # шаг 2: обработка корня
inorder(root.right)         # шаг 3: обход правого поддерева
 
3. Postorder (обратный обход: левое → правое → корень)
Суть: сначала рекурсивно обходим левое и правое поддеревья, затем обрабатываем корень.
Порядок посещения узлов:
Левое поддерево → Правое поддерево → Корень
Рекурсивный алгоритм:
1. Если текущий узел null — выйти.
2. Рекурсивно вызвать postorder для левого ребёнка.
3. Рекурсивно вызвать postorder для правого ребёнка.
4. Обработать значение текущего узла.
Пример последовательности (для того же дерева):
D → E → B → F → G → C → A
Порядок шагов:
1. Рекурсивно обойти левое поддерево.
2. Рекурсивно обойти правое поддерево.
3. Обработать значение текущего узла (корня поддерева).
postorder(root.left)        # шаг 1: обход левого поддерева
postorder(root.right)       # шаг 2: обход правого поддерева
print(root.val, end=" ")  # шаг 3: обработка корня
Сложность по времени: O(n) 
Объяснение временной сложности: O(n) возникает из за того, что каждый узел дерева обрабатывается ровно один раз.
Ответ на контрольный вопрос 5:
Опишите стратегию «разделяй и властвуй» на примере алгоритма сортировки слиянием
Стратегия «разделяй и властвуй» в сортировке слиянием (Merge Sort) работает так: массив рекурсивно делится пополам до подмассивов длиной 1 (тривиально отсортированных), затем отсортированные подмассивы сливаются попарно — на каждом шаге сравниваются элементы подмассивов и в результирующий массив копируется меньший. Процесс повторяется, пока не получится один полностью отсортированный массив. Временная сложность алгоритма — O(n log n), пространственная — O(n) изза дополнительной памяти для слияния.