вариант 16- реализуйте три вида обхода бинарного дерева (preorder, inorder, postorder).

Preorder (прямой обход: корень → левое → правое)
Суть: сначала обрабатываем текущий узел, затем рекурсивно обходим левое и правое поддеревья.
Порядок посещения узлов:
Корень → Левое поддерево → Правое поддерево
Рекурсивный алгоритм:
Если текущий узел null — выйти (базовый случай).
Обработать (вывести/сохранить) значение текущего узла.
Рекурсивно вызвать preorder для левого ребёнка.
Рекурсивно вызвать preorder для правого ребёнка.
Пример последовательности :
A → B → D → E → C → F → G
Шаги:
Порядок шагов:
Обработать (вывести/сохранить) значение текущего узла (корня поддерева).
Рекурсивно обойти левое поддерево.
Рекурсивно обойти правое поддерево.
print(root.val, end=" ")  # шаг 1: обработка корня
preorder(root.left)         # шаг 2: обход левого поддерева
preorder(root.right)        # шаг 3: обход правого поддерева

Inorder (центральный обход: левое → корень → правое)
Суть: рекурсивно обходим левое поддерево, затем обрабатываем корень, затем правое поддерево.
Порядок посещения узлов:
Левое поддерево → Корень → Правое поддерево
Рекурсивный алгоритм:
Если текущий узел null — выйти.
Рекурсивно вызвать inorder для левого ребёнка.
Обработать значение текущего узла.
Рекурсивно вызвать inorder для правого ребёнка.
Пример последовательности (для того же дерева):
D → B → E → A → F → C → G
Порядок шагов:
Рекурсивно обойти левое поддерево.
Обработать значение текущего узла (корня поддерева).
Рекурсивно обойти правое поддерево.
inorder(root.left)          # шаг 1: обход левого поддерева
print(root.val, end=" ")   # шаг 2: обработка корня
inorder(root.right)         # шаг 3: обход правого поддерева
 

Postorder (обратный обход: левое → правое → корень)
Суть: сначала рекурсивно обходим левое и правое поддеревья, затем обрабатываем корень.
Порядок посещения узлов:
Левое поддерево → Правое поддерево → Корень
Рекурсивный алгоритм:
Если текущий узел null — выйти.
Рекурсивно вызвать postorder для левого ребёнка.
Рекурсивно вызвать postorder для правого ребёнка.
Обработать значение текущего узла.
Пример последовательности (для того же дерева):
D → E → B → F → G → C → A
Порядок шагов:
Рекурсивно обойти левое поддерево.
Рекурсивно обойти правое поддерево.
Обработать значение текущего узла (корня поддерева).
postorder(root.left)        # шаг 1: обход левого поддерева
postorder(root.right)       # шаг 2: обход правого поддерева
print(root.val, end=" ")  # шаг 3: обработка корня

Сложность по времени: O(n) 
Объяснение временной сложности: O(n) возникает из за того, что каждый узел дерева обрабатывается ровно один раз.

Ответ на контрольный вопрос 5:
Опишите стратегию «разделяй и властвуй» на примере алгоритма сортировки слиянием
Стратегия «разделяй и властвуй» в сортировке слиянием (Merge Sort) работает так: массив рекурсивно делится пополам до подмассивов длиной 1 (тривиально отсортированных), затем отсортированные подмассивы сливаются попарно — на каждом шаге сравниваются элементы подмассивов и в результирующий массив копируется меньший. Процесс повторяется, пока не получится один полностью отсортированный массив. Временная сложность алгоритма — O(n log n), пространственная — O(n) изза дополнительной памяти для слияния.