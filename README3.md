Сортировка выбором (Selection Sort) 
Этот алгоритм последовательно находит наименьший элемент в неупорядоченном сегменте списка и ставит его в начало этого сегмента.
Описание: Проходим по массиву, начиная с первого элемента.
Пошаговое выполнение работы:
1. Для каждой позиции в массиве ищем наименьший элемент среди всех оставшихся справа от текущей позиции.
2. Найденный минимальный элемент меняем местами с элементом на текущей позиции. min_index = i for j in range(i + 1, len(arr)):  if arr[j] < arr[min_index]:       min_index = j
3. Таким образом, отсортированная часть массива постепенно увеличивается слева направо. arr[i], arr[min_index] = arr[min_index], arr[i]
Сложность: Временная сложность составляет O(n²), так как для каждого из n элементов приходится просматривать в среднем n/2 элементов для поиска минимума. Это справедливо для лучшего, среднего и худшего случаев.
Пример:
· Исходные данные: [23, 56, 21, 41, 12] · Результат: [12, 21, 23, 41, 56]

Сортировка пузырьком (Bubble Sort) Алгоритм многократно проходит по списку, попарно сравнивая соседние элементы и меняя их местами, если они идут в неправильном порядке, пока массив не будет отсортирован.
Описание: Выполняется несколько проходов по массиву от начала до конца.
Пошаговое выполнение работы:
1. На каждом проходе сравниваются пары соседних элементов. for i in range(len(arr) - 1):
2. Если элемент слева больше элемента справа, они меняются местами. for j in range(0, len(arr) - i - 1): if arr[j] > arr[j + 1]:
3. В результате каждого такого прохода самый большой элемент как бы "всплывает" к концу массива. arr[j], arr[j + 1] = arr[j + 1], arr[j]
Сложность: В худшем и среднем случае сложность квадратичная — O(n²). Однако если массив уже отсортирован, алгоритм может завершить работу за O(n), сделав всего один проход без перестановок.
Пример: · Исходные данные: [64, 34, 25, 12, 22, 11, 90] · Результат: [11, 12, 22, 25, 34, 64, 90]

Сортировка вставками (Insertion Sort) 
Алгоритм строит отсортированную последовательность, по одному элементу за раз, вставляя каждый новый элемент в правильную позицию внутри уже упорядоченной части.
Описание: Считается, что первый элемент массива уже отсортирован.
Пошаговое выполнение работы:
1. Берётся следующий элемент и последовательно сравнивается с элементами в отсортированной части справа налево. for i in range(1, len(arr)): key = arr[i]
2. Все элементы, которые больше текущего, сдвигаются вправо, чтобы освободить место для вставки. j = i -  while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1
3. Текущий элемент помещается на найденную правильную позицию. arr[j + 1] = key
Сложность: Сложность в худшем и среднем случае — O(n²). Если массив почти отсортирован, метод работает очень быстро, со сложностью O(n).
Пример: · Исходные данные: [15, 8, 42, 4, 23, 16] · Результат: [4, 8, 15, 16, 23, 42]

Сортировка слиянием (Merge Sort) 
Это алгоритм, основанный на стратегии "разделяй и властвуй". Он рекурсивно разбивает массив на мелкие части, сортирует их, а затем объединяет (сливает) в один отсортированный массив.
Описание: Массив рекурсивно делится пополам до тех пор, пока не останутся подмассивы из одного элемента (которые по определению отсортированы).
Пошаговое выполнение работы:
1. Затем эти подмассивы попарно объединяются в новые отсортированные массивы. mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:])
2. Процесс объединения продолжается до тех пор, пока не будет собран один полностью отсортированный массив. result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i])        i += 1    else:        result.append(right[j])        j += 1
Сложность: Время работы всегда составляет O(n log n), что делает алгоритм очень предсказуемым. Это достигается за счет логарифмического количества шагов деления и линейного времени на слияние на каждом шаге.
Пример: · Исходные данные: [38, 27, 43, 3, 9, 82, 10] · Результат: [3, 9, 10, 27, 38, 43, 82]

Сортировка Шелла (Shell Sort) Усовершенствованный вариант сортировки вставками, который сортирует элементы, находящиеся на определённом расстоянии друг от друга, постепенно уменьшая это расстояние.
Описание: Выбирается интервал, например, половина длины массива.
Пошаговое выполнение работы:
1. Массив сортируется вставками, но элементы сравниваются не с соседями, а с элементами на расстоянии этого шага. gap = len(arr) // 2 while gap > 0:
2. Шаг последовательно уменьшается (чаще всего делением на 2). for i in range(gap, len(arr)):    temp = arr[i]    j = i    while j >= gap and arr[j - gap] > temp:        arr[j] = arr[j - gap]        j -= gap    arr[j] = temp
3. Завершается алгоритм сортировкой вставками с шагом 1, что гарантирует окончательную упорядоченность. gap //= 2
Сложность: Сложность зависит от выбранной последовательности шагов. В среднем стремится к O(n log n), а в худшем случае может быть O(n²).
Пример: · Исходные данные: [23, 12, 1, 8, 34, 54, 2, 3] · Результат: [1, 2, 3, 8, 12, 23, 34, 54]

Быстрая сортировка (Quick Sort) 
Ещё один алгоритм "разделяй и властвуй", который выбирает опорный элемент и перераспределяет остальные элементы так, чтобы меньшие оказались слева от него, а большие — справа, после чего рекурсивно сортирует обе части.
Описание: Из массива выбирается опорный элемент.
Пошаговое выполнение работы:
1. Массив разбивается на две части: элементы меньше опорного и элементы больше опорного. pivot = arr[len(arr) // 2]
2. Рекурсивное применение алгоритма к левому и правому подмассивам. left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot]
3. Базовый случай рекурсии — подмассив из одного или нуля элементов, который считается отсортированным. return quick_sort(left) + middle + quick_sort(right)
Сложность: В среднем случае одна из самых быстрых сортировок со сложностью O(n log n). В худшем случае (неудачный выбор опорного элемента) деградирует до O(n²).
Пример: · Исходные данные: [24, 15, 38, 2, 19, 41, 8] · Результат: [2, 8, 15, 19, 24, 38, 41]

Пирамидальная сортировка (Heap Sort) Алгоритм использует древовидную структуру данных под названием "куча" (пирамида) для эффективного выбора элементов.
Описание: На основе массива строится специальная структура — max-куча, где родительский элемент всегда больше дочерних.
Пошаговое выполнение работы:
1. Самый большой элемент находится в корне кучи. Его меняют местами с последним элементом массива. for i in range(len(arr) // 2 - 1, -1, -1):    heapify(arr, len(arr), i)
2. Уменьшив размер кучи, восстанавливают её свойства для оставшихся элементов, чтобы следующий максимальный элемент оказался в корне. for i in range(len(arr) - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i]  # перемещаем корень в конец heapify(arr, i, 0)  # восстанавливаем кучу
3. Процесс повторяется, пока в куче не останется один элемент. def heapify(arr, n, i):    largest = i    left = 2 * i + 1    right = 2 * i + 2    if left < n and arr[left] > arr[largest]:        largest = left    if right < n and arr[right] > arr[largest]:        largest = right    if largest != i:        arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest)
Сложность: Имеет гарантированную временную сложность O(n log n) для всех случаев, так как построение кучи и каждое извлечение выполняются за логарифмическое время.
Пример: · Исходные данные: [4, 10, 3, 5, 1] · Результат: [1, 3, 4, 5, 10]