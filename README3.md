1. Сортировка выбором (Selection Sort)
Этот алгоритм последовательно находит наименьший элемент в неупорядоченном сегменте списка и ставит его в начало этого сегмента.

Описание: Проходим по массиву, начиная с первого элемента.

Пошаговое выполнение работы:
1. Для каждой позиции в массиве ищем наименьший элемент среди всех оставшихся справа от текущей позиции.
2. Найденный минимальный элемент меняем местами с элементом на текущей позиции.
3. Таким образом, отсортированная часть массива постепенно увеличивается слева направо.

Сложность: Временная сложность составляет O(n²), так как для каждого из n элементов приходится просматривать в среднем n/2 элементов для поиска минимума. Это справедливо для лучшего, среднего и худшего случаев.

Пример:

· Исходные данные: [23, 56, 21, 41, 12]
· Результат: [12, 21, 23, 41, 56]

2. Сортировка пузырьком (Bubble Sort)
Алгоритм многократно проходит по списку, попарно сравнивая соседние элементы и меняя их местами, если они идут в неправильном порядке, пока массив не будет отсортирован.

Описание: Выполняется несколько проходов по массиву от начала до конца.

Пошаговое выполнение работы:
1. На каждом проходе сравниваются пары соседних элементов.
2. Если элемент слева больше элемента справа, они меняются местами.
3. В результате каждого такого прохода самый большой элемент как бы "всплывает" к концу массива.

Сложность: В худшем и среднем случае сложность квадратичная — O(n²). Однако если массив уже отсортирован, алгоритм может завершить работу за O(n), сделав всего один проход без перестановок.

Пример:
· Исходные данные: [64, 34, 25, 12, 22, 11, 90]
· Результат: [11, 12, 22, 25, 34, 64, 90]

3. Сортировка вставками (Insertion Sort)
Алгоритм строит отсортированную последовательность, по одному элементу за раз, вставляя каждый новый элемент в правильную позицию внутри уже упорядоченной части.

Описание: Считается, что первый элемент массива уже отсортирован.

Пошаговое выполнение работы:
1. Берётся следующий элемент и последовательно сравнивается с элементами в отсортированной части справа налево.
2. Все элементы, которые больше текущего, сдвигаются вправо, чтобы освободить место для вставки.
3. Текущий элемент помещается на найденную правильную позицию.

Сложность: Сложность в худшем и среднем случае — O(n²). Если массив почти отсортирован, метод работает очень быстро, со сложностью O(n).

Пример:
· Исходные данные: [15, 8, 42, 4, 23, 16]
· Результат: [4, 8, 15, 16, 23, 42]


4. Сортировка слиянием (Merge Sort)
Это алгоритм, основанный на стратегии "разделяй и властвуй". Он рекурсивно разбивает массив на мелкие части, сортирует их, а затем объединяет (сливает) в один отсортированный массив.

Описание: Массив рекурсивно делится пополам до тех пор, пока не останутся подмассивы из одного элемента (которые по определению отсортированы).

Пошаговое выполнение работы:
1. Затем эти подмассивы попарно объединяются в новые отсортированные массивы.
2. Процесс объединения продолжается до тех пор, пока не будет собран один полностью отсортированный массив.

Сложность: Время работы всегда составляет O(n log n), что делает алгоритм очень предсказуемым. Это достигается за счет логарифмического количества шагов деления и линейного времени на слияние на каждом шаге.

Пример:
· Исходные данные: [38, 27, 43, 3, 9, 82, 10]
· Результат: [3, 9, 10, 27, 38, 43, 82]


5. Сортировка Шелла (Shell Sort)
Усовершенствованный вариант сортировки вставками, который сортирует элементы, находящиеся на определённом расстоянии друг от друга, постепенно уменьшая это расстояние.

Описание: Выбирается интервал, например, половина длины массива.

Пошаговое выполнение работы:
1. Массив сортируется вставками, но элементы сравниваются не с соседями, а с элементами на расстоянии этого шага.
2. Шаг последовательно уменьшается (чаще всего делением на 2).
3. Завершается алгоритм сортировкой вставками с шагом 1, что гарантирует окончательную упорядоченность.

Сложность: Сложность зависит от выбранной последовательности шагов. В среднем стремится к O(n log n), а в худшем случае может быть O(n²).

Пример:
· Исходные данные: [23, 12, 1, 8, 34, 54, 2, 3]
· Результат: [1, 2, 3, 8, 12, 23, 34, 54]

6. Быстрая сортировка (Quick Sort)
Ещё один алгоритм "разделяй и властвуй", который выбирает опорный элемент и перераспределяет остальные элементы так, чтобы меньшие оказались слева от него, а большие — справа, после чего рекурсивно сортирует обе части.

Описание: Из массива выбирается опорный элемент. 

Пошаговое выполнение работы:
1. Массив разбивается на две части: элементы меньше опорного и элементы больше опорного.
2. Рекурсивное применение алгоритма к левому и правому подмассивам.
3. Базовый случай рекурсии — подмассив из одного или нуля элементов, который считается отсортированным.

Сложность: В среднем случае одна из самых быстрых сортировок со сложностью O(n log n). В худшем случае (неудачный выбор опорного элемента) деградирует до O(n²).

Пример:
· Исходные данные: [24, 15, 38, 2, 19, 41, 8]
· Результат: [2, 8, 15, 19, 24, 38, 41]


7. Пирамидальная сортировка (Heap Sort)
Алгоритм использует древовидную структуру данных под названием "куча" (пирамида) для эффективного выбора элементов.

Описание: На основе массива строится специальная структура — max-куча, где родительский элемент всегда больше дочерних.

Пошаговое выполнение работы:
1. Самый большой элемент находится в корне кучи. Его меняют местами с последним элементом массива.
2. Уменьшив размер кучи, восстанавливают её свойства для оставшихся элементов, чтобы следующий максимальный элемент оказался в корне.
3. Процесс повторяется, пока в куче не останется один элемент.

Сложность: Имеет гарантированную временную сложность O(n log n) для всех случаев, так как построение кучи и каждое извлечение выполняются за логарифмическое время.

Пример:
· Исходные данные: [4, 10, 3, 5, 1]
· Результат: [1, 3, 4, 5, 10]